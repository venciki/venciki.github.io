---
title: 浏览器缓存策略
date: 2025-07-12
categories:
  - 浏览器
tags:
  - HTTP
  - 缓存
---

## 浏览器缓存策略

浏览器每次发起请求时，都会先在本地缓存中查找结果以及缓存标识，通过缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并列带缓存标识。根据是否需要向服务器发起 HTTP 请求，将缓存过程分为两部分：强制缓存和协商缓存，强缓存优先于协商缓存。
+ `强缓存`，服务器通知一浏览器一个缓存时间，在缓存时间内，下次请求都将使用本地缓存，不在缓存时间内，则执行协商缓存策略。
+ `协商缓存`，让客户端和服务端之间能实现缓存文件是否更新的验证，提升缓存的复用率，将缓存中信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

HTTP 缓存都是从第二次请求开始的：
+ 第一次请求资源时，服务器返回资源，并在 response header 中回传资源的缓存策略。
+ 第二次请求时，浏览器判断这些请求参数，击中强缓存直接就 200， 否则就把请求参数加到 request header 中传给服务器，看是否击中协商缓存，击中就返回304，否则服务器会返回新的资源。

## 强缓存
1. 强缓存命中则直接读取浏览器本地的资源，在 network 中显示的是 from memory 或者 from disk。
2. 强缓存的控制字段有 Cache-Control（http1.1）和 Exprise（http1.0）
3. Cache-Control 是一个相对时间，用以表示自上次请求正确的资源之后的多少秒的时间段内缓存有效。
4. Exprise 是一个绝对时间，用以表达这个时间点前发起请求可以直接从浏览器中读取数据，而无需发起请求，
5. Cache-Control 的优先级比 Exprise 的优先级高。前者的出现是为了解决 Exprise 的浏览器时间被手动更改导缓存致判断错误的问题。如果同时出现则使用Cache-Control。

### Exprise

`Exprise` 如上述所说是一个绝对的过期时间，用以表达这个时间点前发起请求可以直接从浏览器中读取数据，而无需发起请求。

但这种方式存在一个**问题**，那就是服务器的时间和浏览器的时间可能并不一致（浏览器的时间也可以被修改），那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。

### Cache-Control

在 HTTP1.1 中，采用了一个非常关键的字段：Cache-Control，如上述所说，它是是采用过期时长来控制缓存，对应字段是 `max-age`。比如
```
Cache-Control:max-age=3600
```
代表这个响应返回后在 3600 秒内可以直接使用缓存。

除了 max-age，Cache-Control 还有如下字段：

+ **public**: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的 `代理服务器` 最后才能到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。

+ **private**: 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。

+ **no-cache**: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。

+ **no-store**:  非常粗暴，不进行任何形式的缓存。

+ **s-maxage**: 这和 max-age 很像，但区别是 s-maxage 是针对代理服务器的缓存时间。

+ **must-revalidate**: 如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。



当缓存时间过期了，也就是强缓存失效了，接下来就会进入到 `协商缓存`。


## 协商缓存

1. 协商缓存的状态码由服务器决策返回 200 或者 304
2. 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modeified-Since 或者 If-None-Match 的时候，会讲这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 Etag 属性。
3. 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的紧紧是一个状态码而已，并且没有实际的文件内容，因此在响应体体积上的节省是他的优化点。
4. 协商缓存有 2 组字段（不是两个），控制协商协商缓存的字段有：Last-Modified/If-Modified-Since (Http1.0) 和 Etag/If-None-Match(http1.1)
5. `Last-Modified / If-Modified-Since `表示的是服务器的资源最后一次修改的时间; Etag / If-None-Match 表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成。
6. Etag / If-None-Match 的优先级比 last-Modified / If-Modified-Since高。

### Last-Modified/If-Modified-since

1. 服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间，例如：`Last-Modified: Mon, 10 Nov 2025 09:10:11 GMT`
2. 浏览器将这值和内容一起记录在缓存数据库中。
3. 下次请求相同资源时，浏览器从自己的缓存中找出 “不确定是否过期的” 缓存。因此在请求头中将上次的 `Last-Modified` 的值 写入到请求头的 `If-Modified-Since` 字段。
4. 服务器会将 `If-Modified-Since` 的值与 `Last-Modified` 字段进行比对。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。


劣势问题：
1. 只要是资源修改，无论内容是否发生实质性的变化，都会讲该资源返回客户端。例如周期性充血，这种情况下资源包含的数据实际是一样的。
2. 以时刻作为标识，无法识别一秒内进行多次修改的情况。如果资源更新速度是秒以下单位，那么该缓存是不能不使用的，因为他的时间单位最低是秒。
3. 
### Etag/If-None-Match
+ 为了解决上述问题，出现了一组新的字段 `Etag` 和 `If-None-Match`
+ Etag 存储的是文件的特殊标识（一般都是 hash 生成的），服务器存储着文件的 Etag 字段。之后的流程和 Last-Modified 一致，只是 Last-Modified 字段和他所标识的更新时间改变成了 Etag 字段和它所表示的 hash，把 `If-Modified-Since` 变成了 `If-None-Match`。服务器同样进行比较，命中返回 304，不命中返回新资源和200。
+ 浏览器在发起请求时，服务器返回在 Response header 中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的 `Etag` 值赋值给 `If-None-Match` 并添加在 Request header 中。服务器将浏览器传来的 If-None-Match跟自己本地的资源的 Etag 做对比，如果匹配，则返回 304 通知浏览器读取本地缓存，否则返回 200 和 更新后的资源。
+ **Etag 的优先级高于 Last-Modified**