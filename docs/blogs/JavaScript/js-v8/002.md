---
title: JavaScript 宏任务、微任务、EventLoop-浏览器
date: 2025-06-29
categories:
  - JavaScript
tags:
  - JavaScript
---

## 1. 宏任务(MacroTask)

在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:

1. 渲染事件
2. 用户交互事件
3. js 脚本执行
4. 网络请求、文件读写完成事件等等

为了让这些事件有条不紊地进行，JS 引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种`队列`的方式来存储这些任务， 即先进来的先执行。

其中包含了两种任务队列，除了上述提到的任务队列， 还有一个延迟队列，它专门处理诸如setTimeout/setInterval这样的定时器回调任务。

上述提到的，普通任务队列和延迟队列中的任务，都属于宏任务。

## 2. 微任务(MicroTask)引入

对于每个宏任务而言，其内部都有一个微任务队列。那为什么要引入微任务？微任务在什么时候执行呢？


其实引入微任务的初衷是为了解决异步回调的问题。对于异步回调的处理，总结起来有两点:

1. 将异步回调进行宏任务队列的入队操作。
2. 将异步回调放到当前宏任务的末尾。

如果采用第一种方式，那么执行回调的时机应该是在前面`所有的宏任务`完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。

为了规避这样的问题，V8 引入了第二种方式，这就是`微任务`的解决方式。在每一个宏任务中定义一个`微任务队列`，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。

常见的微任务:Promise.then(或.reject)、MutationObserver 以及以 Promise 为基础开发的其他技术(比如fetch API)。

## 3. EventLoop--浏览器

分析一个例子：
```js
console.log('start');
setTimeout(() => {
  console.log('timeout');
});
Promise.resolve().then(() => {
  console.log('resolve');
});
console.log('end');
```

1. 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印 start 和 end
2. 遇到宏任务 setTimeout，放进宏任务队列
3. 遇到微任务 Promise.then，放进微任务队列
4. 宏任务执行完成，查找微任务队列，发现 Promise.then，执行并打印 relove
5. 接下来进入到下一个宏任务队列--setTimeout执行，打印 timeout

打印顺序
```js
start
end
resolve
timeout
```

**完整过程**

1. 一开始整段脚本作为第一个宏任务执行。
2. 执行过程中，同步任务直接执行，宏任务放进宏任务队列，微任务放进微任务队列。
3. 当前宏任务执行完后，检查微任务队列，如果有则执行微任务，直到微任务队列为空。
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有Web worker任务，有则执行
6. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空




