---
title: 深拷贝
date: 2025-07-15
categories:
  - JavaScript
tags:
  - JavaScript
  - 手写
---

## 1. 简易版

```js
JSON.pares(JSON.stringfy())
```

此 api 能覆盖大多数场景，但实际上在某些严格场景，此方法有坑：

1. 无法解决循环引用问题，举个例子：

```js
const a = {val: 2};
a.target = a;
```

拷贝 a 会出现系统栈溢出，因为出现了无限递归的情况。

2. 无法拷贝一些特殊对象，比如 RegExp，Date，Set，Map等。

3. 无法拷贝函数

先写一个简易版的：
```js
function deepClone(target) {
    if (typeof target === 'object') {
        const resultObj = Array.isArray(target) ? [] : {};
        for (let props in target) {
            if (target.hasOwnProperty(props)) {
                resultObj[props] = deepClone(target[props]);
            }
        }
        return resultObj;
    }
    else {
        return target;
    }
}
```

## 2. 解决循环引用
...
## 3. 拷贝特殊对象
...
## 4. 拷贝函数
...