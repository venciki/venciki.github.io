---
title: JS 继承方式
date: 2025-06-26
categories:
  - JavaScript
tags:
  - JavaScript
---

## 1. 原型链式继承

```js
function Father() {
    this.lastName = 'Zhang';
    this.color = ['yellow'];
    this.lang = 'Chinese';
}

function Child() {}

Child.prototype = new Father();

const child1 = new Child();
child1.color.push('white');

console.log(child1.lastName); // Zhang
console.log(child1.color); // ['yellow', 'white']

const child2 = new Child();
console.log(child2.color); // ['yellow', 'white']
```

优点：
+ 简单，易于实现

缺点：
+ 引用类型的原型属性会被所有实例共享。简而言之 修改了child1的color后，child2也随之改变。
+ 创建子类时，无法向父类构造函数传参

## 2.借用构造函数
```js
function Father(number) {
    this.lastName = 'Zhang';
    this.color = ['yellow'];
    this.lang = 'Chinese';
    this.number = number;
}

function Child() {
    Father.call(this, '123')
}

const child1 = new Child();
child1.color.push('white');

console.log(child1.color); // ['yellow', 'white']
console.log(child1.number); // '123'

const child2 = new Child();
console.log(child2.color); // ['yellow']

```

优点：

+ 可以向父类传递参数
+ 解决了子类实例共享引用属性的问题

缺点：
+ 无法实现函数复用。方法都是在父类原型上定义的，对于子类是不可见的。

## 3. 组合式继承
将原型链和借用构造函数的技术组和到一块。即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。

```js
function Father(number) {
    this.lastName = 'Zhang';
    this.color = ['yellow'];
    this.lang = 'Chinese';
    this.number = number;
}

function Child(number) {
    Father.call(this, number);
}

Father.prototype.callChild = function() {
    console.log('Back home!!!');
}

Child.prototype = new Father();

const child1 = new Child(111);

child1.callChild(); // Back home!!!
child1.color.push('white'); //
console.log(child1.number); // 111

```

优点：

+ 不存在引用属性共享问题
+ 可以传参
+ 函数可复用

缺点：

+ 因为父类构造函数被调用了两次

## 4.原型式继承